name: Daily Turso Database Backup

on:
  schedule:
    # Run daily at 2 AM UTC
    - cron: '0 2 * * *'
  workflow_dispatch: # Allow manual triggering

# Security: Restrict permissions to minimum required
permissions:
  contents: write # To create branches and commit files
  actions: read # To read workflow files

jobs:
  backup:
    runs-on: ubuntu-latest

    # Security: Set timeout to prevent runaway processes
    timeout-minutes: 30

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Install dependencies
        run: |
          # Install SQLite3 for database operations
          sudo apt-get update
          sudo apt-get install -y sqlite3

      - name: Install Turso CLI
        run: |
          # Install using the official installer
          curl -sSfL https://get.tur.so/install.sh | bash
          
          # Add to PATH for this session
          echo "$HOME/.turso" >> $GITHUB_PATH
          export PATH="$HOME/.turso:$PATH"
          
          # Verify CLI installation
          turso --version

      - name: Authenticate with Turso
        run: |
          # Verify authentication using environment variable
          turso db list >/dev/null || { echo "Authentication failed"; exit 1; }
        env:
          TURSO_AUTH_TOKEN: ${{ secrets.TURSO_AUTH_TOKEN }}

      - name: Create backup
        run: |
          DATE=$(date +"%Y-%m-%d")
          TIMESTAMP=$(date -Iseconds)

          # Stay on main branch
          git checkout main
          git pull origin main

          # Create backups directory if it doesn't exist
          mkdir -p backups

          # Test database connectivity before backup
          if ! turso db show "$TURSO_DATABASE_NAME" >/dev/null 2>&1; then
            echo "ERROR: Cannot access database $TURSO_DATABASE_NAME"
            exit 1
          fi

          # Create backup with error handling
          echo "Creating backup for database: $TURSO_DATABASE_NAME"
          if ! turso db export "$TURSO_DATABASE_NAME" --output-file "temp_backup_${DATE}.db"; then
            echo "ERROR: Database export failed"
            exit 1
          fi

          # Convert SQLite to SQL dump for better compatibility
          sqlite3 "temp_backup_${DATE}.db" .dump > "temp_backup_${DATE}.sql"
          rm -f "temp_backup_${DATE}.db"

          # Verify backup is not empty
          if [ ! -s "temp_backup_${DATE}.sql" ]; then
            echo "ERROR: Backup file is empty"
            rm -f "temp_backup_${DATE}.sql"
            exit 1
          fi

          # Security: Encrypt backup before storing
          gpg --symmetric --cipher-algo AES256 --batch --yes \
              --passphrase "$BACKUP_ENCRYPTION_KEY" \
              --output "backups/backup-${DATE}.sql.gpg" \
              "temp_backup_${DATE}.sql"

          # Clean up temporary file
          rm -f "temp_backup_${DATE}.sql"

          # Get backup file size for verification
          BACKUP_SIZE=$(stat -c%s "backups/backup-${DATE}.sql.gpg")

          # Create a backup manifest with metadata (no sensitive data)
          cat > "backups/backup-${DATE}-manifest.json" << EOF
          {
            "timestamp": "$TIMESTAMP",
            "date": "$DATE",
            "database_name_hash": "$(echo -n "$TURSO_DATABASE_NAME" | sha256sum | cut -d' ' -f1)",
            "backup_file": "backup-${DATE}.sql.gpg",
            "backup_size_bytes": $BACKUP_SIZE,
            "encrypted": true,
            "encryption_algo": "AES256",
            "commit_sha": "${{ github.sha }}",
            "runner_id": "${{ github.run_id }}",
            "workflow_run_id": "${{ github.run_number }}",
            "backup_status": "success"
          }
          EOF

          echo "‚úÖ Backup created successfully: ${BACKUP_SIZE} bytes"

        env:
          # GitHub Actions secret references (VS Code warnings are false positives)
          TURSO_AUTH_TOKEN: ${{ secrets.TURSO_AUTH_TOKEN }}
          TURSO_DATABASE_NAME: ${{ secrets.TURSO_DATABASE_NAME }}
          BACKUP_ENCRYPTION_KEY: ${{ secrets.BACKUP_ENCRYPTION_KEY }}

      - name: Commit backup to repository
        run: |
          DATE=$(date +"%Y-%m-%d")

          # Add files to git
          git add backups/

          # Configure git user (use noreply email)
          git config user.name "GitHub Action Bot"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

          # Check if there are changes to commit
          if git diff --cached --quiet; then
            echo "No changes to commit"
            exit 0
          fi

          # Commit and push to main
          git commit -m "chore: automated database backup for ${DATE} [skip ci]

          üì¶ Backup Details:
          - Date: ${DATE}
          - Encrypted: Yes (AES256)
          - Workflow Run: ${{ github.run_number }}
          - SHA: ${{ github.sha }}"

          git push origin main

          echo "‚úÖ Backup committed and pushed successfully"

      - name: Clean up old backups
        run: |
          # Keep only last 30 days of backups
          CUTOFF_DATE=$(date -d '30 days ago' +%Y-%m-%d)
          DELETED_COUNT=0

          echo "üßπ Cleaning up backups older than $CUTOFF_DATE"

          # Security: Clean up old encrypted backups
          find backups/ -name "backup-*.sql.gpg" -type f | while read file; do
            FILE_DATE=$(echo "$file" | grep -oE '[0-9]{4}-[0-9]{2}-[0-9]{2}')
            if [[ "$FILE_DATE" < "$CUTOFF_DATE" ]]; then
              echo "Removing old backup: $file"
              rm -f "$file"
              rm -f "backups/backup-${FILE_DATE}-manifest.json"
              DELETED_COUNT=$((DELETED_COUNT + 1))
            fi
          done

          # Commit cleanup if files were removed
          if ! git diff --quiet; then
            git add backups/
            git commit -m "chore: cleanup old backups older than 30 days [skip ci]

            üóëÔ∏è Cleanup Details:
            - Cutoff date: $CUTOFF_DATE
            - Files removed: $DELETED_COUNT backup sets"
            git push origin main
            echo "‚úÖ Old backups cleaned up and committed"
          else
            echo "‚ÑπÔ∏è No old backups to clean up"
          fi

      - name: Security scan of backup files
        run: |
          echo "üîç Running security scan on backup manifests..."

          # Verify no sensitive data leaked in manifests
          if find backups/ -name "*.json" -exec grep -l "password\|secret\|key\|token\|auth" {} \; | grep -q .; then
            echo "‚ùå ERROR: Sensitive data detected in backup manifests!"
            find backups/ -name "*.json" -exec grep -Hn "password\|secret\|key\|token\|auth" {} \;
            exit 1
          fi

          # Verify all backup files are encrypted
          if find backups/ -name "*.sql" -not -name "*.gpg" | grep -q .; then
            echo "‚ùå ERROR: Unencrypted SQL files detected!"
            find backups/ -name "*.sql" -not -name "*.gpg"
            exit 1
          fi

          echo "‚úÖ Security scan passed: No sensitive data or unencrypted files detected"

      - name: Backup verification
        run: |
          DATE=$(date +"%Y-%m-%d")

          echo "üîç Verifying today's backup..."

          # Check if backup file exists and has content
          if [ ! -f "backups/backup-${DATE}.sql.gpg" ]; then
            echo "‚ùå ERROR: Backup file not found!"
            exit 1
          fi

          # Check file size (should be > 1KB for reasonable backup)
          BACKUP_SIZE=$(stat -c%s "backups/backup-${DATE}.sql.gpg" 2>/dev/null || echo "0")
          if [ "$BACKUP_SIZE" -lt 1024 ]; then
            echo "‚ùå ERROR: Backup file too small (${BACKUP_SIZE} bytes)"
            exit 1
          fi

          # Check if manifest exists
          if [ ! -f "backups/backup-${DATE}-manifest.json" ]; then
            echo "‚ùå ERROR: Backup manifest not found!"
            exit 1
          fi

          echo "‚úÖ Backup verification passed: ${BACKUP_SIZE} bytes"
          echo "üìä Backup Summary:"
          echo "   - File: backups/backup-${DATE}.sql.gpg"
          echo "   - Size: ${BACKUP_SIZE} bytes"
          echo "   - Manifest: ‚úÖ"
          echo "   - Encrypted: ‚úÖ"
