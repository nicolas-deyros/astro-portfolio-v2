diff --git a/src/content/blog/from-zero-to-ai-hero.mdx b/src/content/blog/from-zero-to-ai-hero.mdx
index f5dffaa..9ca1a9c 100644
--- a/src/content/blog/from-zero-to-ai-hero.mdx
+++ b/src/content/blog/from-zero-to-ai-hero.mdx
@@ -1,76 +1,76 @@
 ---
-title: 'From Zero to AI Hero: How Gemini CLI Transformed Blog'
+title: 'Engineering the Agentic Loop: Antigravity, Gemini & MCPs'
 slug: 'from-zero-to-ai-hero'
-description: 'A technical deep-dive into integrating Gemini CLI with my portfolio, detailing a hybrid AI architecture and a fully automated development workflow.'
-date: 'Jan 15 2026'
+description: 'A technical deep dive into building an autonomous development workflow with Antigravity, Gemini CLI, and the Model Context Protocol (MCP).'
+date: 'Jan 16 2026'
 author: 'Nicol√°s Deyros'
 image:
   src: '/src/assets/blog/ai-orchestration.png'
-  alt: 'AI Orchestration'
+  alt: 'Technical diagram of AI Agent Orchestration'
 tags:
-  [
-    'Gemini',
-    'AI',
-    'Astro',
-    'Workflow',
-    'Automation',
-    'DevEx',
-    'TDD',
-    'Architecture',
-  ]
+  ['Antigravity', 'Gemini', 'MCP', 'TestSprite', 'Automation', 'DevEx', 'Astro']
 category: 'Artificial Intelligence'
 draft: false
 ---
 
 import { Image } from 'astro:assets'
-import Video from '@components/Video.astro'
 import AI_Orchestration from '../../assets/blog/ai-orchestration.png'
 
 <Image
 	src={AI_Orchestration}
-	alt="AI Orchestration"
+	alt="AI Agent Orchestration"
 	class="mb-8 w-full rounded-lg shadow-lg"
 />
 
-A few months ago, I embarked on an experiment: could an AI assistant go beyond generating code snippets and become a true development partner? I wanted to integrate **Gemini CLI** into the heart of my portfolio, a modern site built with **Astro**, to automate my workflow and enrich the content with generative AI.
+The transition from "AI as a Chatbot" to "AI as an Engineering Agent" happens when you close the loop between reasoning and execution. In this technical deep dive, I‚Äôll explain how I architected an autonomous engineering system using **Antigravity**, **Gemini CLI**, and a specialized stack of **Model Context Protocol (MCP)** servers.
 
-The result exceeded all my expectations. Not only did I automate repetitive tasks, but I ended up designing a sophisticated hybrid AI architecture. This is the story of how I did it.
+### üõ∏ The Antigravity Orchestration Engine
 
-### The Foundation: A "Zero-Touch" Workflow
+At the heart of my workflow is **Antigravity**‚Äîan autonomous agent designed to navigate complex codebases. Unlike standard LLMs, Antigravity operates as a "Pilot" that connects **Gemini's 1.5 Pro/Flash** reasoning models directly to my local filesystem and terminal.
 
-Before adding AI features, I needed a bulletproof development process. My goal was simple: **automate everything that wasn't creative coding**. Using Gemini CLI and the **Conductor** extension to plan the task, I created a series of scripts that revolutionized my Developer Experience (DevEx):
+The connection is established via a suite of automation tools in `tools/` that standardize our interactions:
 
-- `npm run session:init`: Starts a development session, syncs the main branch, and updates dependencies.
-- `npm run git:start`: Creates a new branch, makes an initial commit, and **automatically opens a draft Pull Request on GitHub**.
-- `npm run docs:sync`: Analyzes changes and automatically updates the `CHANGELOG.md` and other relevant documents.
+- **`session:init`**: An AI-driven environment audit that syncs Git state, verifies Node/NPM versions, and updates dependencies.
+- **`git:start`**: A programmatic bridge that initializes features, creates conventional branches, and uses the **GitHub CLI** to open Draft PRs automatically.
+- **`git:ship`**: The final delivery sequence‚ÄîAntigravity runs a full validation suite (Lighthouse, Vitest, Playwright), pushes the code, and initiates an auto-merge via GitHub.
 
-With this system, starting a new feature is as simple as running one command. Gemini handles all the Git bureaucracy, allowing me to focus 100% on the solution.
+### üîå Scaling Intelligence with MCP
 
-### The Brain: A Resilient, Hybrid AI Architecture
+The **Model Context Protocol (MCP)** is the "USB-C for AI." It allows Antigravity to plug into specialized intelligence silos. My current "Agentic Stack" includes:
 
-For the AI features on the blog (summaries and translations), I didn't want to rely on a single cloud API. Inspired by privacy and speed, I designed a hybrid model:
+1.  **TestSprite MCP**: This is my autonomous QA department. It analyzes my code, generates a **Standardized PRD**, and writes/executes its own end-to-end tests without human intervention.
+2.  **Astro Docs MCP**: Provides Antigravity with real-time, RAG-enhanced access to the latest Astro documentation, preventing "hallucinations" on new framework features.
+3.  **GitHub MCP**: Deep integration with the repository lifecycle‚Äîmanaging issues, PR comments, and CI/CD status checks.
+4.  **Chrome DevTools MCP**: Allows the agent to "see" into the browser during E2E testing, inspecting the DOM and console logs to debug hydration issues in real-time.
+5.  **ESLint & CSS MCPs**: Programmatic code quality gates that ensure every line Antigravity writes adheres to the project's strict styling and logic rules.
 
-1.  **Local First (Chrome AI)**: The application first attempts to use the **Gemini Nano** model built into the Chrome browser. This is incredibly fast, works offline, and keeps user data on their machine.
-2.  **Cloud Fallback (Gemini 1.5 Flash)**: If the local API isn't available (e.g., in an unsupported browser), the system transparently falls back to an `api/ai/process` endpoint on my own backend. This endpoint uses the powerful and cost-effective **Gemini 1.5 Flash** API.
+### üß† The Hybrid AI Architecture
 
-To optimize even further, I implemented a **caching layer in the Astro DB**. Generated results are saved, so future requests for the same content are instantaneous and don't consume API quota.
+For the blog's frontend features (like Summarization and Translation), I engineered a **Hybrid AI Strategy** designed for resilience:
 
-### The Magic in Action: Smart Summaries and Translations
+```mermaid
+graph TD
+    A[User Request] --> B{Browser Support?}
+    B -- Yes --> C[Gemini Nano / Chrome AI]
+    B -- No --> D[Gemini 1.5 Flash Cloud]
+    C -- Timeout/Fail --> D
+    D --> E[Astro DB Cache Check]
+    E -- Miss --> F[Cloud Generation]
+    F --> G[Store in AICache]
+    G --> H[Return Result]
+    E -- Hit --> H
+```
 
-With the architecture in place, the next step was to build the features. Guided by a plan in **Conductor**, I used a strict **Test-Driven Development (TDD)** approach:
+- **Local Processing**: We prioritize **Gemini Nano** (Chrome‚Äôs on-device model) for data privacy and zero-latency.
+- **Resilient Fallback**: If the experimental Chrome APIs fail (e.g., model download timeouts), the system transparently flips to a server-side endpoint powered by `gemini-1.5-flash`.
+- **Intelligent Caching**: We implemented an `AICache` table in **Astro DB**. By hashing the content, we ensure that we never pay for the same summary twice, significantly reducing API overhead and improving user response times.
 
-1.  **Red Phase**: Write failing tests for all use cases and error conditions (API unavailable, network error, etc.).
-2.  **Green Phase**: Implement the logic in the React components (`BlogSummarizer.tsx` and `BlogTranslator.tsx`) until the tests pass.
-3.  **Refactor**: Clean up and optimize the code.
+### üõ†Ô∏è Technical Resilience in Agentic Workflows
 
-The result is robust components that gracefully handle loading states, errors, and display the AI-generated results clearly to the user.
+Building with autonomous agents requires "Defensive Engineering." Every tool Antigravity uses is wrapped in robust error handling. For instance, our **GitHub Automation** handles merge conflicts via the AI's own reasoning, while our **Grammar Checker** utility (`tools/grammar-checker.ts`) automatically cleans up residual metadata to keep the history clean.
 
-### Master Orchestration with Conductor
+### üéØ Conclusion: The Future of DevEx
 
-None of this was improvised. Each of these major tasks was meticulously planned in `plan.md` files using the **Conductor** extension. This allowed me to break down complex problems into phases and checkpoints, and to guide Gemini every step of the way, ensuring the final implementation aligned perfectly with the architectural vision.
+By combining Gemini's reasoning with the tool-using capabilities of Antigravity and the extensibility of MCP, I‚Äôve moved from "coding" to "orchestrating." This setup allows me to maintain a **100 Lighthouse score** and 80%+ test coverage while focusing 100% on architecture rather than boilerplate.
 
-### Conclusion: A Partner, Not Just an Assistant
-
-Integrating Gemini CLI has transformed the way I work. I went from using a tool that generates code to collaborating with a partner that helps me **plan, architect, implement, and maintain** complex software.
-
-The combination of an automated workflow, a resilient AI architecture, and structured planning has elevated the quality and sophistication of my project while supercharging my productivity. The future of development isn't just about using AI, but about integrating it natively into our processes and architectures. And that future is already here.
+The era of the "Solo Dev" is ending; the era of the **Orchestrator** has begun.
